// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: proto/sardine.proto

package sardine

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AssignClient is the client API for Assign service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AssignClient interface {
	// 注册业务tag 漫长的等待～
	RegSection(ctx context.Context, in *RegSectionReq, opts ...grpc.CallOption) (*RegSectionResp, error)
	// 注册业务tag 漫长的等待～
	UnRegSection(ctx context.Context, in *UnRegSectionReq, opts ...grpc.CallOption) (*UnRegSectionResp, error)
}

type assignClient struct {
	cc grpc.ClientConnInterface
}

func NewAssignClient(cc grpc.ClientConnInterface) AssignClient {
	return &assignClient{cc}
}

func (c *assignClient) RegSection(ctx context.Context, in *RegSectionReq, opts ...grpc.CallOption) (*RegSectionResp, error) {
	out := new(RegSectionResp)
	err := c.cc.Invoke(ctx, "/Sardine.assign/RegSection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assignClient) UnRegSection(ctx context.Context, in *UnRegSectionReq, opts ...grpc.CallOption) (*UnRegSectionResp, error) {
	out := new(UnRegSectionResp)
	err := c.cc.Invoke(ctx, "/Sardine.assign/UnRegSection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AssignServer is the server API for Assign service.
// All implementations must embed UnimplementedAssignServer
// for forward compatibility
type AssignServer interface {
	// 注册业务tag 漫长的等待～
	RegSection(context.Context, *RegSectionReq) (*RegSectionResp, error)
	// 注册业务tag 漫长的等待～
	UnRegSection(context.Context, *UnRegSectionReq) (*UnRegSectionResp, error)
	mustEmbedUnimplementedAssignServer()
}

// UnimplementedAssignServer must be embedded to have forward compatible implementations.
type UnimplementedAssignServer struct {
}

func (UnimplementedAssignServer) RegSection(context.Context, *RegSectionReq) (*RegSectionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegSection not implemented")
}
func (UnimplementedAssignServer) UnRegSection(context.Context, *UnRegSectionReq) (*UnRegSectionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnRegSection not implemented")
}
func (UnimplementedAssignServer) mustEmbedUnimplementedAssignServer() {}

// UnsafeAssignServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AssignServer will
// result in compilation errors.
type UnsafeAssignServer interface {
	mustEmbedUnimplementedAssignServer()
}

func RegisterAssignServer(s grpc.ServiceRegistrar, srv AssignServer) {
	s.RegisterService(&Assign_ServiceDesc, srv)
}

func _Assign_RegSection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegSectionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssignServer).RegSection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Sardine.assign/RegSection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssignServer).RegSection(ctx, req.(*RegSectionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Assign_UnRegSection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnRegSectionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssignServer).UnRegSection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Sardine.assign/UnRegSection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssignServer).UnRegSection(ctx, req.(*UnRegSectionReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Assign_ServiceDesc is the grpc.ServiceDesc for Assign service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Assign_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Sardine.assign",
	HandlerType: (*AssignServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegSection",
			Handler:    _Assign_RegSection_Handler,
		},
		{
			MethodName: "UnRegSection",
			Handler:    _Assign_UnRegSection_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sardine.proto",
}

// AllocClient is the client API for Alloc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AllocClient interface {
	// 生成单个id指定tag的Seq
	GenUserSeq(ctx context.Context, in *GenUserSeqReq, opts ...grpc.CallOption) (*GenUserSeqResp, error)
	// 获取单个id指定tag的Seq
	GetUserSeq(ctx context.Context, in *GetUserSeqReq, opts ...grpc.CallOption) (*GetUserSeqResp, error)
}

type allocClient struct {
	cc grpc.ClientConnInterface
}

func NewAllocClient(cc grpc.ClientConnInterface) AllocClient {
	return &allocClient{cc}
}

func (c *allocClient) GenUserSeq(ctx context.Context, in *GenUserSeqReq, opts ...grpc.CallOption) (*GenUserSeqResp, error) {
	out := new(GenUserSeqResp)
	err := c.cc.Invoke(ctx, "/Sardine.alloc/GenUserSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *allocClient) GetUserSeq(ctx context.Context, in *GetUserSeqReq, opts ...grpc.CallOption) (*GetUserSeqResp, error) {
	out := new(GetUserSeqResp)
	err := c.cc.Invoke(ctx, "/Sardine.alloc/GetUserSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AllocServer is the server API for Alloc service.
// All implementations must embed UnimplementedAllocServer
// for forward compatibility
type AllocServer interface {
	// 生成单个id指定tag的Seq
	GenUserSeq(context.Context, *GenUserSeqReq) (*GenUserSeqResp, error)
	// 获取单个id指定tag的Seq
	GetUserSeq(context.Context, *GetUserSeqReq) (*GetUserSeqResp, error)
	mustEmbedUnimplementedAllocServer()
}

// UnimplementedAllocServer must be embedded to have forward compatible implementations.
type UnimplementedAllocServer struct {
}

func (UnimplementedAllocServer) GenUserSeq(context.Context, *GenUserSeqReq) (*GenUserSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenUserSeq not implemented")
}
func (UnimplementedAllocServer) GetUserSeq(context.Context, *GetUserSeqReq) (*GetUserSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserSeq not implemented")
}
func (UnimplementedAllocServer) mustEmbedUnimplementedAllocServer() {}

// UnsafeAllocServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AllocServer will
// result in compilation errors.
type UnsafeAllocServer interface {
	mustEmbedUnimplementedAllocServer()
}

func RegisterAllocServer(s grpc.ServiceRegistrar, srv AllocServer) {
	s.RegisterService(&Alloc_ServiceDesc, srv)
}

func _Alloc_GenUserSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenUserSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AllocServer).GenUserSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Sardine.alloc/GenUserSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AllocServer).GenUserSeq(ctx, req.(*GenUserSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Alloc_GetUserSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AllocServer).GetUserSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Sardine.alloc/GetUserSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AllocServer).GetUserSeq(ctx, req.(*GetUserSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Alloc_ServiceDesc is the grpc.ServiceDesc for Alloc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Alloc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Sardine.alloc",
	HandlerType: (*AllocServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenUserSeq",
			Handler:    _Alloc_GenUserSeq_Handler,
		},
		{
			MethodName: "GetUserSeq",
			Handler:    _Alloc_GetUserSeq_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sardine.proto",
}

// ProxyClient is the client API for Proxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProxyClient interface {
	// 生成单个id指定tag的Seq    单调递增但不保证连续性
	GenUserSeq(ctx context.Context, in *GenUserSeqReq, opts ...grpc.CallOption) (*GenUserSeqResp, error)
	// 获取单个id指定tag的Seq    小概率获取到比实际Seq大的Seq（服务重启，缓存失效）
	GetUserSeq(ctx context.Context, in *GetUserSeqReq, opts ...grpc.CallOption) (*GetUserSeqResp, error)
	// 生成单个id多个tag的Seq    单调递增但不保证连续性
	GenUserMultiSeq(ctx context.Context, in *GenUserMultiSeqReq, opts ...grpc.CallOption) (*GenUserMultiSeqResp, error)
	// 获取单个id多个tag的Seq    小概率获取到比实际Seq大的Seq（服务重启，缓存失效）
	GetUserMultiSeq(ctx context.Context, in *GetUserMultiSeqReq, opts ...grpc.CallOption) (*GetUserMultiSeqResp, error)
	// 生成多个id指定tag的Seq    单调递增但不保证连续性
	BatchGenUserSeq(ctx context.Context, in *BatchGenUserSeqReq, opts ...grpc.CallOption) (*BatchGenUserSeqResp, error)
	// 获取多个id指定tag的Seq    小概率获取到比实际Seq大的Seq（服务重启，缓存失效）
	BatchGetUserSeq(ctx context.Context, in *BatchGetUserSeqReq, opts ...grpc.CallOption) (*BatchGetUserSeqResp, error)
}

type proxyClient struct {
	cc grpc.ClientConnInterface
}

func NewProxyClient(cc grpc.ClientConnInterface) ProxyClient {
	return &proxyClient{cc}
}

func (c *proxyClient) GenUserSeq(ctx context.Context, in *GenUserSeqReq, opts ...grpc.CallOption) (*GenUserSeqResp, error) {
	out := new(GenUserSeqResp)
	err := c.cc.Invoke(ctx, "/Sardine.proxy/GenUserSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) GetUserSeq(ctx context.Context, in *GetUserSeqReq, opts ...grpc.CallOption) (*GetUserSeqResp, error) {
	out := new(GetUserSeqResp)
	err := c.cc.Invoke(ctx, "/Sardine.proxy/GetUserSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) GenUserMultiSeq(ctx context.Context, in *GenUserMultiSeqReq, opts ...grpc.CallOption) (*GenUserMultiSeqResp, error) {
	out := new(GenUserMultiSeqResp)
	err := c.cc.Invoke(ctx, "/Sardine.proxy/GenUserMultiSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) GetUserMultiSeq(ctx context.Context, in *GetUserMultiSeqReq, opts ...grpc.CallOption) (*GetUserMultiSeqResp, error) {
	out := new(GetUserMultiSeqResp)
	err := c.cc.Invoke(ctx, "/Sardine.proxy/GetUserMultiSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) BatchGenUserSeq(ctx context.Context, in *BatchGenUserSeqReq, opts ...grpc.CallOption) (*BatchGenUserSeqResp, error) {
	out := new(BatchGenUserSeqResp)
	err := c.cc.Invoke(ctx, "/Sardine.proxy/BatchGenUserSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) BatchGetUserSeq(ctx context.Context, in *BatchGetUserSeqReq, opts ...grpc.CallOption) (*BatchGetUserSeqResp, error) {
	out := new(BatchGetUserSeqResp)
	err := c.cc.Invoke(ctx, "/Sardine.proxy/BatchGetUserSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProxyServer is the server API for Proxy service.
// All implementations must embed UnimplementedProxyServer
// for forward compatibility
type ProxyServer interface {
	// 生成单个id指定tag的Seq    单调递增但不保证连续性
	GenUserSeq(context.Context, *GenUserSeqReq) (*GenUserSeqResp, error)
	// 获取单个id指定tag的Seq    小概率获取到比实际Seq大的Seq（服务重启，缓存失效）
	GetUserSeq(context.Context, *GetUserSeqReq) (*GetUserSeqResp, error)
	// 生成单个id多个tag的Seq    单调递增但不保证连续性
	GenUserMultiSeq(context.Context, *GenUserMultiSeqReq) (*GenUserMultiSeqResp, error)
	// 获取单个id多个tag的Seq    小概率获取到比实际Seq大的Seq（服务重启，缓存失效）
	GetUserMultiSeq(context.Context, *GetUserMultiSeqReq) (*GetUserMultiSeqResp, error)
	// 生成多个id指定tag的Seq    单调递增但不保证连续性
	BatchGenUserSeq(context.Context, *BatchGenUserSeqReq) (*BatchGenUserSeqResp, error)
	// 获取多个id指定tag的Seq    小概率获取到比实际Seq大的Seq（服务重启，缓存失效）
	BatchGetUserSeq(context.Context, *BatchGetUserSeqReq) (*BatchGetUserSeqResp, error)
	mustEmbedUnimplementedProxyServer()
}

// UnimplementedProxyServer must be embedded to have forward compatible implementations.
type UnimplementedProxyServer struct {
}

func (UnimplementedProxyServer) GenUserSeq(context.Context, *GenUserSeqReq) (*GenUserSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenUserSeq not implemented")
}
func (UnimplementedProxyServer) GetUserSeq(context.Context, *GetUserSeqReq) (*GetUserSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserSeq not implemented")
}
func (UnimplementedProxyServer) GenUserMultiSeq(context.Context, *GenUserMultiSeqReq) (*GenUserMultiSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenUserMultiSeq not implemented")
}
func (UnimplementedProxyServer) GetUserMultiSeq(context.Context, *GetUserMultiSeqReq) (*GetUserMultiSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserMultiSeq not implemented")
}
func (UnimplementedProxyServer) BatchGenUserSeq(context.Context, *BatchGenUserSeqReq) (*BatchGenUserSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGenUserSeq not implemented")
}
func (UnimplementedProxyServer) BatchGetUserSeq(context.Context, *BatchGetUserSeqReq) (*BatchGetUserSeqResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGetUserSeq not implemented")
}
func (UnimplementedProxyServer) mustEmbedUnimplementedProxyServer() {}

// UnsafeProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProxyServer will
// result in compilation errors.
type UnsafeProxyServer interface {
	mustEmbedUnimplementedProxyServer()
}

func RegisterProxyServer(s grpc.ServiceRegistrar, srv ProxyServer) {
	s.RegisterService(&Proxy_ServiceDesc, srv)
}

func _Proxy_GenUserSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenUserSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).GenUserSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Sardine.proxy/GenUserSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).GenUserSeq(ctx, req.(*GenUserSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_GetUserSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).GetUserSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Sardine.proxy/GetUserSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).GetUserSeq(ctx, req.(*GetUserSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_GenUserMultiSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenUserMultiSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).GenUserMultiSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Sardine.proxy/GenUserMultiSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).GenUserMultiSeq(ctx, req.(*GenUserMultiSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_GetUserMultiSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserMultiSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).GetUserMultiSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Sardine.proxy/GetUserMultiSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).GetUserMultiSeq(ctx, req.(*GetUserMultiSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_BatchGenUserSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGenUserSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).BatchGenUserSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Sardine.proxy/BatchGenUserSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).BatchGenUserSeq(ctx, req.(*BatchGenUserSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_BatchGetUserSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetUserSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).BatchGetUserSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Sardine.proxy/BatchGetUserSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).BatchGetUserSeq(ctx, req.(*BatchGetUserSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_ServiceDesc is the grpc.ServiceDesc for Proxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Sardine.proxy",
	HandlerType: (*ProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenUserSeq",
			Handler:    _Proxy_GenUserSeq_Handler,
		},
		{
			MethodName: "GetUserSeq",
			Handler:    _Proxy_GetUserSeq_Handler,
		},
		{
			MethodName: "GenUserMultiSeq",
			Handler:    _Proxy_GenUserMultiSeq_Handler,
		},
		{
			MethodName: "GetUserMultiSeq",
			Handler:    _Proxy_GetUserMultiSeq_Handler,
		},
		{
			MethodName: "BatchGenUserSeq",
			Handler:    _Proxy_BatchGenUserSeq_Handler,
		},
		{
			MethodName: "BatchGetUserSeq",
			Handler:    _Proxy_BatchGetUserSeq_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sardine.proto",
}
